# Tipos Fundamentales en C++

---

## Tipos Fundamentales

Los **tipos fundamentales** son los bloques b√°sicos para construir tipos y estructuras de datos m√°s complejas como:

- Listas
- Hash maps
- √Årboles
- Grafos
- Etc.

---

## Variables

### Declaraci√≥n de variables

```cpp
type variable = value;
type variable {value};   // C++11
````

Ejemplo:

```cpp
// declarar e inicializar 'i'
int i = 1;
// imprimir el valor de i
cout << i << '\n';

int j {5};
cout << j << '\n';
```

### Concepto importante

Un **objeto** es un conjunto de bits interpretados seg√∫n un tipo.

‚ö†Ô∏è **Las variables de tipos fundamentales NO se inicializan por defecto**

```cpp
int k;        // k NO inicializada
cout << k;    // el valor puede ser cualquier cosa
```

Esto ocurre porque en C++ **solo pagas por lo que usas**
(la inicializaci√≥n de grandes bloques de memoria puede ser costosa).

üëâ **Pero**: casi siempre debes inicializar las variables al declararlas para evitar errores.

---

## Panorama r√°pido de tipos de datos fundamentales

### Booleanos

```cpp
bool b1 = true;
bool b2 = false;
```

---

### Caracteres (`char`)

* Entero m√°s peque√±o
* Tama√±o definido: **1 byte** (normalmente 8 bits)
* En x86/x86_64 suele ser *signed*: valores en `[-128, 127]`

```cpp
char c = 'A';  // literal de car√°cter
char a = 65;   // equivalente a 'A'
```

---

### Enteros con signo

Con `n` bits:
valores en `[-2^(n-1), 2^(n-1)-1]`

```cpp
short s = 7;
int i = 12347;
long l1 = -7856974990L;
long long l2 = 89565656974990LL;

// Separador de d√≠gitos (C++14)
long l3 = 512'232'697'499;
```

---

### Enteros sin signo

Con `n` bits:
valores en `[0, 2^n - 1]`

```cpp
unsigned u1 = 12347U;
unsigned long u2 = 123478912345UL;
unsigned long long u3 = 123478912345ULL;

// Literales no decimales
unsigned x = 0x4A;        // hexadecimal
unsigned b = 0b10110101;  // binario (C++14)
```

---

### Tipos de punto flotante

* `float`: usualmente IEEE 754 de 32 bits
* `double`: usualmente IEEE 754 de 64 bits
* `long double`: normalmente 80 bits en x86/x86-64

```cpp
float f = 1.88f;
double d1 = 3.5e38;
long double d2 = 3.5e38L;   // C++11

double d3 = 512'232'697'499.052; // separador de d√≠gitos
```

---

## Representaci√≥n num√©rica com√∫n

* Enteros sin signo
* Enteros con signo
* N√∫meros de punto flotante IEEE 754

Todos se representan internamente en **binario**.

---

## Operaciones aritm√©ticas

### Operadores

* `a ‚äï b` ‚Üí devuelve el resultado
* `a ‚äï= b` ‚Üí guarda el resultado en `a`

```cpp
int a = 4;
int b = 3;

a = a + b;
a += b;

a = a - b;
a -= b;

a = a * b;
a *= b;

a = a / b;
a /= b;

a = a % b;  // m√≥dulo
```

---

## Incremento y decremento

* Cambian el valor en ¬±1
* Prefijo: devuelve el valor nuevo
* Postfijo: devuelve el valor anterior

```cpp
int a = 4;
int b = 3;

b = a++;   // postfijo
b = ++a;   // prefijo
b = --a;
b = a--;
```

---

## Comparaciones

### Comparaciones binarias

El resultado siempre es `true` o `false`.

```cpp
int x = 10;
int y = 5;

bool b1 = x == 5;
bool b2 = x != 6;
bool b3 = x > y;
bool b4 = x < y;
bool b5 = y >= 5;
bool b6 = x <= 30;
```

---

### Comparaciones de 3 v√≠as (`<=>`) ‚Äì C++20

```cpp
(a <=> b) < 0   // a < b
(a <=> b) > 0   // a > b
(a <=> b) == 0  // a == b
```

Devuelven un tipo de comparaci√≥n:

* `std::strong_ordering`
* `std::weak_ordering`
* `std::partial_ordering`

Ejemplos:

```cpp
4 <=> 6  // less
5 <=> 5  // equal
8 <=> 1  // greater
```

---

## L√≥gica booleana

### Operadores

```cpp
bool a = true;
bool b = false;

bool c = a && b;   // AND
bool d = a || b;   // OR
bool e = !a;       // NOT
```

### Escritura alternativa

```cpp
bool x = a and b;
bool y = a or b;
bool z = not a;
```

---

### Conversi√≥n a `bool`

* `0` ‚Üí false
* cualquier otro valor ‚Üí true

```cpp
bool f = 12;   // true
bool g = 0;    // false
bool h = 1.2;  // true
```

---

### Evaluaci√≥n de corto circuito

```cpp
int i = 2;
int k = 8;

bool b1 = (i > 0) || (k < 3);
```

`k < 3` **no se eval√∫a** porque el resultado ya se conoce.

---

## Tama√±os en memoria

Todos los tama√±os son m√∫ltiplos de `sizeof(char)`.

```cpp
cout << sizeof(char);   // 1
cout << sizeof(bool);   // 1
cout << sizeof(short);  // 2
cout << sizeof(int);    // 4
cout << sizeof(long);   // 8

cout << CHAR_BIT;       // bits en un char (usualmente 8)
```

‚ö†Ô∏è **Los tama√±os dependen de la plataforma**

Garant√≠as b√°sicas:

```text
sizeof(short) ‚â• sizeof(char)
sizeof(int)   ‚â• sizeof(short)
sizeof(long)  ‚â• sizeof(int)
```

---

## Tama√±os garantizados ‚Äì C++11

```cpp
#include <cstdint>

int8_t, int16_t, int32_t, int64_t
uint8_t, uint16_t, uint32_t, uint64_t
```

Tambi√©n existen:

* `int_leastX_t`
* `int_fastX_t`

---

## Tipos flotantes de tama√±o fijo ‚Äì C++23

```cpp
#include <stdfloat>

std::float16_t
std::float32_t
std::float64_t
std::float128_t
std::bfloat16_t
```

---

## `std::numeric_limits`

```cpp
#include <limits>

std::numeric_limits<double>::lowest();
std::numeric_limits<double>::min();
std::numeric_limits<double>::max();
std::numeric_limits<double>::epsilon();
```

Permite conocer l√≠mites y propiedades de los tipos num√©ricos.

---

## Narrowing (reducci√≥n de tipo)

Conversi√≥n de un tipo que puede representar **m√°s valores** a uno que puede representar **menos**.

* Puede perder informaci√≥n
* Generalmente **no genera advertencia**
* Fuente com√∫n de bugs

```cpp
double d = 1.23456;
float f = 2.53f;
unsigned u = 120u;

int i = 2.5;  // narrowing
int j = u;    // narrowing
int k = f;    // narrowing
```

---

## Inicializaci√≥n con llaves ‚Äì C++11

Detecta conversiones peligrosas:

```cpp
int i {2.5};   // ADVERTENCIA
int j {u};     // ADVERTENCIA
int k {f};     // ADVERTENCIA
```

üëâ **Usa llaves para evitar conversiones silenciosas**

---

# Operaciones Bit a Bit (Bitwise Operations)

## Operadores

- `a & b`  AND bit a bit  
- `a | b`  OR bit a bit  
- `a ^ b`  XOR bit a bit  
- `~a`     NOT bit a bit (complemento a uno)

---

## Ejemplo completo en c√≥digo

```cpp
#include <iostream>
#include <bitset>
#include <cstdint>

int main() {
    std::uint8_t a = 6;          // 0000 0110
    std::uint8_t b = 0b00001011; // 0000 1011

    std::uint8_t c1 = (a & b);
    std::uint8_t c2 = (a | b);
    std::uint8_t c3 = (a ^ b);
    std::uint8_t c4 = ~a;
    std::uint8_t c5 = ~b;

    std::cout << "a      = " << std::bitset<8>(a)  << '\n'; // 0000 0110
    std::cout << "b      = " << std::bitset<8>(b)  << '\n'; // 0000 1011
    std::cout << "a & b  = " << std::bitset<8>(c1) << '\n'; // 0000 0010
    std::cout << "a | b  = " << std::bitset<8>(c2) << '\n'; // 0000 1111
    std::cout << "a ^ b  = " << std::bitset<8>(c3) << '\n'; // 0000 1101
    std::cout << "~a     = " << std::bitset<8>(c4) << '\n'; // 1111 1001
    std::cout << "~b     = " << std::bitset<8>(c5) << '\n'; // 1111 0100

    bool a_odd  = a & 1;    // 0 ‚áí false
    bool a_even = !(a & 1);  //1 ‚áí true

    std::cout << "a es impar? " << a_odd  << '\n';
    std::cout << "a es par?   " << a_even << '\n';

    return 0;
}
```


---

# Bitwise Shifts (Desplazamientos de bits)

## Operadores

- `x << n`  desplaza los bits de `x` a la izquierda
- `x >> n`  desplaza los bits de `x` a la derecha
- `x <<= n` modifica `x` desplazando a la izquierda
- `x >>= n` modifica `x` desplazando a la derecha

---

## Ejemplo con impresi√≥n de bits (8 bits)

```cpp
#include <iostream>
#include <bitset>
#include <cstdint>

int main() {
    std::uint8_t a = 1;

    std::cout << "Inicial:\n";
    std::cout << std::bitset<8>(a) << '\n';

    a <<= 6;
    std::cout << "Despues de a <<= 6:\n";
    std::cout << std::bitset<8>(a) << '\n';

    a >>= 4;
    std::cout << "Despues de a >>= 4:\n";
    std::cout << std::bitset<8>(a) << '\n';

    return 0;
}
```

‚ö†Ô∏è Desplazar m√°s bits de los que tiene el tipo es **comportamiento indefinido**.

```cpp
std::uint32_t i = 1;
i <<= 32;   // indefinido
```

---

## Conversiones y promociones aritm√©ticas

En C++ existen reglas (heredadas de C) para decidir:

- el **tipo com√∫n** de los operandos
- el **tipo del resultado** de una operaci√≥n binaria

## Notaci√≥n

```

Operando A ‚äï Operando B ‚Üí Resultado

```

Donde `‚äï` representa una operaci√≥n aritm√©tica (`+`, `-`, `*`, `/`, `%`).

---

## Resumen simplificado de reglas

### Operaciones con al menos un tipo de punto flotante

```

long double ‚äï cualquier tipo   ‚Üí long double
double ‚äï float                ‚Üí double
double ‚äï entero               ‚Üí double
float ‚äï entero                ‚Üí float

```

---

### Operaciones entre tipos enteros

Primero ocurre **promoci√≥n de enteros**:

- Todo tipo m√°s peque√±o que `int`
  se promueve a:
  - `int` o
  - `unsigned int`
  (seg√∫n cu√°l pueda representar todos los valores)

Despu√©s ocurre **conversi√≥n de enteros** si los tipos siguen siendo distintos.

---

### Reglas de conversi√≥n entre enteros

#### Ambos con signo (signed)

```

tipo m√°s peque√±o ‚Üí tipo m√°s grande

```

#### Ambos sin signo (unsigned)

```

tipo m√°s peque√±o ‚Üí tipo m√°s grande

```

#### Mezcla: signed ‚äï unsigned

1. Si ambos tienen el **mismo tama√±o**:
```

signed ‚Üí unsigned

```

2. Si el tipo con signo puede representar
   **todos los valores** del unsigned:
```

unsigned ‚Üí signed

```

3. En cualquier otro caso:
```

ambos ‚Üí unsigned

```

---

## Nota importante

Estas conversiones suelen ocurrir:

- de forma **autom√°tica**
- **sin advertencias del compilador**
- y pueden causar errores dif√≠ciles de detectar

Especial cuidado con operaciones entre:
- `signed` y `unsigned`

## Nota final

Evita:

* Conversiones impl√≠citas
* Narrowing silencioso
* Mezclar tipos sin entender las reglas

Esto previene errores dif√≠ciles de detectar en tiempo de ejecuci√≥n.

---